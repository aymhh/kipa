class Text {
    constructor(text) {
        this._text = text;
        Object.defineProperty(this, "actions", {
            value: [],
            enumerable: true
        });
        Object.defineProperty(this, "toString", {
            value: () => this._text,
            enumerable: true
        });
    }
    bold(arg, max) {
        if (typeof arg === "undefined") {
            this._text = "**" + this._text + "**";
            this.actions.push({
                action: "bold",
                toString: () => "bold",
                limit: null
            });
            return this;
        }
        if (typeof arg === "number") {
            if (!max) max = arg;
            arg = 0;
            const split = this._text.split("");
            split.splice(arg, 0, "**");
            split.splice(max, 0, "**");
            this._text = split.join("");
            
            this.actions.push({
                action: "bold",
                toString: () => "bold",
                limit: [arg, max]
            });
            return this;
        }
        if (arg instanceof RegExp || typeof arg === "string") {
            this._text = this._text.replace(arg, "**$&**");
            this.actions.push({
                action: "bold",
                toString: () => "bold",
                limit: arg
            });
            return this;
        }
        this._text = "**" + this._text + "**";
        this.actions.push({
            action: "bold",
            toString: () => "bold",
            limit: arg // not supported
        });
        return this;
    }
    spoiler(arg, max) {
        if (typeof arg === "undefined") {
            this._text = "||" + this._text + "||";
            this.actions.push({
                action: "spoiler",
                toString: () => "spoiler",
                limit: null
            });
            return this;
        }
        if (typeof arg === "number") {
            if (!max) max = arg;
            arg = 0;
            const split = this._text.split("");
            split.splice(arg, 0, "||");
            split.splice(max, 0, "||");
            this._text = split.join("");
            
            this.actions.push({
                action: "spolier",
                toString: () => "spoiler",
                limit: [arg, max]
            });
            return this;
        }
        if (arg instanceof RegExp || typeof arg === "string") {
            this._text = this._text.replace(arg, "||$&||");
            this.actions.push({
                action: "spoiler",
                toString: () => "spoiler",
                limit: arg
            });
            return this;
        }
        this._text = "||" + this._text + "||";
        this.actions.push({
            action: "spoiler",
            toString: () => "spoiler",
            limit: arg // not supported
        });
        return this;
    }
    italic(arg, max) {
        if (typeof arg === "undefined") {
            this._text = "*" + this._text + "*";
            this.actions.push({
                action: "italic",
                toString: () => "italic",
                limit: null
            });
            return this;
        }
        if (typeof arg === "number") {
            if (!max) max = arg;
            arg = 0;
            const split = this._text.split("");
            split.splice(arg, 0, "*");
            split.splice(max, 0, "*");
            this._text = split.join("");
            
            this.actions.push({
                action: "italic",
                toString: () => "italic",
                limit: [arg, max]
            });
            return this;
        }
        if (arg instanceof RegExp || typeof arg === "string") {
            this._text = this._text.replace(arg, "*$&*");
            this.actions.push({
                action: "italic",
                toString: () => "italic",
                limit: arg
            });
            return this;
        }
        this._text = "*" + this._text + "*";
        this.actions.push({
            action: "italic",
            toString: () => "italic",
            limit: arg // not supported
        });
        return this;
    }
    underline(arg, max) {
        if (typeof arg === "undefined") {
            this._text = "__" + this._text + "__";
            this.actions.push({
                action: "underline",
                toString: () => "underline",
                limit: null
            });
            return this;
        }
        if (typeof arg === "number") {
            if (!max) max = arg;
            arg = 0;
            const split = this._text.split("");
            split.splice(arg, 0, "__");
            split.splice(max, 0, "__");
            this._text = split.join("");
            
            this.actions.push({
                action: "underline",
                toString: () => "underline",
                limit: [arg, max]
            });
            return this;
        }
        if (arg instanceof RegExp || typeof arg === "string") {
            this._text = this._text.replace(arg, "__$&__");
            this.actions.push({
                action: "underline",
                toString: () => "underline",
                limit: arg
            });
            return this;
        }
        this._text = "__" + this._text + "__";
        this.actions.push({
            action: "underline",
            toString: () => "underline",
            limit: arg // not supported
        });
        return this;
    }
    strikethrough(arg, max) {
        if (typeof arg === "undefined") {
            this._text = "~~" + this._text + "~~";
            this.actions.push({
                action: "strikethrough",
                toString: () => "strikethrough",
                limit: null
            });
            return this;
        }
        if (typeof arg === "number") {
            if (!max) max = arg;
            arg = 0;
            const split = this._text.split("");
            split.splice(arg, 0, "~~");
            split.splice(max, 0, "~~");
            this._text = split.join("");
            
            this.actions.push({
                action: "strikethrough",
                toString: () => "strikethrough",
                limit: [arg, max]
            });
            return this;
        }
        if (arg instanceof RegExp || typeof arg === "string") {
            this._text = this._text.replace(arg, "~~$&~~");
            this.actions.push({
                action: "strikethrough",
                toString: () => "strikethrough",
                limit: arg
            });
            return this;
        }
        this._text = "~~" + this._text + "~~";
        this.actions.push({
            action: "strikethrough",
            toString: () => "strikethrough",
            limit: arg // not supported
        });
        return this;
    }
    codeblock(lang, inline, arg, max) {
        const txt = inline ? "`" : "```";
        lang = lang || "";
        
        if (typeof arg === "undefined") {
            this._text = txt + lang + "\n" + this._text + txt;
            this.actions.push({
                action: "codeblock",
                toString: () => "codeblock",
                limit: null,
                inline: !!inline,
                language: lang || null
            });
            return this;
        }
        if (typeof arg === "number") {
            if (!max) max = arg;
            arg = 0;
            const split = this._text.split("");
            split.splice(arg, 0, txt + lang + "\n");
            split.splice(max, 0, txt);
            this._text = split.join("");
            
            this.actions.push({
                action: "codeblock",
                toString: () => "codeblock",
                limit: [arg, max],
                inline: !!inline,
                language: lang || null
            });
            return this;
        }
        if (arg instanceof RegExp || typeof arg === "string") {
            this._text = this._text.replace(arg, `${txt}${lang}\n$&${txt}`);
            this.actions.push({
                action: "codeblock",
                toString: () => "codeblock",
                limit: arg,
                inline: !!inline,
                language: lang || null
            });
            return this;
        }
        this._text = txt + lang + "\n" + this._text + txt;
        this.actions.push({
            action: "codeblock",
            toString: () => "codeblock",
            limit: arg, // not supported
            inline: !!inline,
            language: lang || null
        });
        return this;
    }
    async replaceMention(id, usernameOrClient, prop = "username", includeAt = true) {
        id = `${id}`.split("").filter(c => /\d/.test(c)).join("");
        const getUsername = async () => {
            if (typeof usernameOrClient === "string") return usernameOrClient;
            const fetched = await usernameOrClient.fetchUser(id);
            return fetched[prop] || fetched.username;
        };
        
        this._text = this._text.replace(new RegExp(`<@!?${id}>`, "g"), (includeAt ? "@" : "") + (await getUsername()));
        this.actions.push({
            action: "replaceMention",
            toString: () => "replaceMention",
            id,
            usernameOrClient
        });
        return this;
    }
    replaceMentions(client, prop = "username", includeAt = true) {
        let offset;
        const replaced = {};
        this._text = this._text.replace(
            /<@!?(\d{16,21})>/g,
            (_, id) => {
                const u = client.users.get(id) || { id, prop: id, username: id };
                return (includeAt ? "@" : "") + (u[prop] || u.username);
            }
        );
        this.actions.push({
            action: "replaceMentions",
            toString: () => "replaceMentions",
            client,
            prop,
            includeAt
        });
        return this;
    }
}

module.exports = Text;
